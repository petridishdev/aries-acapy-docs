"use strict";(self.webpackChunkaries_cloud_agent_python_documentation=self.webpackChunkaries_cloud_agent_python_documentation||[]).push([[8900],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>g});var r=a(7294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function n(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,r,s=function(e,t){if(null==e)return{};var a,r,s={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var c=r.createContext({}),l=function(e){var t=r.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):n(n({},t),e)),a},d=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var a=e.components,s=e.mdxType,o=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=l(a),m=s,g=p["".concat(c,".").concat(m)]||p[m]||h[m]||o;return a?r.createElement(g,n(n({ref:t},d),{},{components:a})):r.createElement(g,n({ref:t},d))}));function g(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=a.length,n=new Array(o);n[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[p]="string"==typeof e?e:s,n[1]=i;for(var l=2;l<o;l++)n[l]=a[l];return r.createElement.apply(null,n)}return r.createElement.apply(null,a)}m.displayName="MDXCreateElement"},7026:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>n,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var r=a(7462),s=(a(7294),a(3905));const o={},n="Deeper Dive: DIDComm Messaging",i={unversionedId:"developer/DIDcommMsgs",id:"developer/DIDcommMsgs",title:"Deeper Dive: DIDComm Messaging",description:'DIDComm peer-to-peer messages are asynchronous messages that one agent sends to another - for example, Faber would send to Alice. In between, there may be other agents and message processing, but at the edges, Faber appears to be messaging directly with Alice using encryption based on the DIDs and DIDDocs that the two shared when establishing a connection. The messages are JSON-LD-friendly messages with a "type" that defines the namespace, protocol, protocol version and type of the message, an "id" that is GUID for the message, and additional fields as required by the message type. The namespace is currently defined to be a public DID that should be globally resolvable to a protocol specification. Currently, "core" messages use a DID that is not yet globally resolvable - Daniel Hardman has the keys associated with the DID.',source:"@site/docs/developer/DIDcommMsgs.md",sourceDirName:"developer",slug:"/developer/DIDcommMsgs",permalink:"/aries-acapy-docs/developer/DIDcommMsgs",draft:!1,editUrl:"https://github.com/hyperledger/aries-acapy-docs/tree/main/docs/docusaurus/docs/developer/DIDcommMsgs.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Credential Revocation",permalink:"/aries-acapy-docs/developer/CredentialRevocation"},next:{title:"Decentralized Identity Use Case Demos",permalink:"/aries-acapy-docs/developer/DecentralizedIdentityDemos"}},c={},l=[{value:"Message Decorators",id:"message-decorators",level:2}],d={toc:l},p="wrapper";function h(e){let{components:t,...a}=e;return(0,s.kt)(p,(0,r.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"deeper-dive-didcomm-messaging"},"Deeper Dive: DIDComm Messaging"),(0,s.kt)("p",null,'DIDComm peer-to-peer messages are asynchronous messages that one agent sends to another - for example, Faber would send to Alice. In between, there may be other agents and message processing, but at the edges, Faber appears to be messaging directly with Alice using encryption based on the DIDs and DIDDocs that the two shared when establishing a connection. The messages are JSON-LD-friendly messages with a "type" that defines the namespace, protocol, protocol version and type of the message, an "id" that is GUID for the message, and additional fields as required by the message type. The namespace is currently defined to be a public DID that should be globally resolvable to a protocol specification. Currently, "core" messages use a DID that is not yet globally resolvable - Daniel Hardman has the keys associated with the DID.'),(0,s.kt)("p",null,"Link: ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/hyperledger/aries-rfcs/blob/master/concepts/0020-message-types/README.md"},"Message Types")),(0,s.kt)("p",null,"As protocols are executed, the data associated with the protocol is stored in the (currently named) wallet of the agent. The data primarily consists of the state object for that instance of the protocol, and any artifacts of running the protocol. For example, when establishing a connection, the metadata associated with the connection (DIDs, DID Documents and private keys) is stored in the agent's wallet. Likewise, ledger data is cached in the wallet (DIDs, schema, credential definitions, etc.) and credentials. This is taken care of by the Aries agent and the protocols configured into the agent."),(0,s.kt)("h2",{id:"message-decorators"},"Message Decorators"),(0,s.kt)("p",null,'In addition to protocol specific data elements in messages, messages can include "decorators", standardized message elements that define cross-cutting behavior. The most common example is the "thread" decorator, which is used to link the messages in a protocol instance. As messages go back and forth between agents to complete an instance of a protocol (e.g. issuing a credential), the ',(0,s.kt)("a",{parentName:"p",href:"https://github.com/hyperledger/aries-rfcs/tree/master/concepts/0008-message-id-and-threading"},"thread decorator")," data elements let the agents know to which protocol instance the message belongs. Other currently defined examples of decorators include ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/hyperledger/aries-rfcs/tree/master/concepts/0017-attachments"},"attachments"),", ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/hyperledger/aries-rfcs/blob/master/features/0043-l10n/README.md"},"localization"),", ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/hyperledger/aries-rfcs/blob/master/features/0034-message-tracing/README.md"},"tracing")," and ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/hyperledger/aries-rfcs/blob/master/features/0032-message-timing/README.md"},"timing"),". Decorators are often processed by the core of the agent, but some are processed by the protocol message handlers. For example, the thread decorator processed to retrieve the protocol state object for that instance (thread) of the protocol before control is passed to the protocol message handler."))}h.isMDXComponent=!0}}]);