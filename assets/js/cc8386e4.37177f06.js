"use strict";(self.webpackChunkaries_cloud_agent_python_documentation=self.webpackChunkaries_cloud_agent_python_documentation||[]).push([[2159],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},c="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(n),u=a,h=c["".concat(l,".").concat(u)]||c[u]||g[u]||o;return n?r.createElement(h,i(i({ref:t},p),{},{components:n})):r.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,i[1]=s;for(var d=2;d<o;d++)i[d]=n[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1021:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>g,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var r=n(7462),a=(n(7294),n(3905));const o={},i="Deeper Dive: DIDComm Message Routing and Encryption",s={unversionedId:"developer/RoutingEncryption",id:"developer/RoutingEncryption",title:"Deeper Dive: DIDComm Message Routing and Encryption",description:"Many Aries edge agents do not directly receive messages from a peer edge agent - they have agents in between that route messages to them. This is done for many reasons, such as:",source:"@site/docs/developer/RoutingEncryption.md",sourceDirName:"developer",slug:"/developer/RoutingEncryption",permalink:"/aries-acapy-docs/developer/RoutingEncryption",draft:!1,editUrl:"https://github.com/hyperledger/aries-acapy-docs/tree/main/docs/docusaurus/docs/developer/RoutingEncryption.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Presenting Indy Proofs",permalink:"/aries-acapy-docs/developer/PresentingIndyProofs"},next:{title:"Starting Your Own Aries Agent",permalink:"/aries-acapy-docs/developer/YourOwnAriesAgent"}},l={},d=[{value:"Inbound Routing - Mediators",id:"inbound-routing---mediators",level:2},{value:"Relays",id:"relays",level:2},{value:"Message Encryption",id:"message-encryption",level:2}],p={toc:d},c="wrapper";function g(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"deeper-dive-didcomm-message-routing-and-encryption"},"Deeper Dive: DIDComm Message Routing and Encryption"),(0,a.kt)("p",null,"Many Aries edge agents do not directly receive messages from a peer edge agent - they have agents in between that route messages to them. This is done for many reasons, such as: "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The agent is on a mobile device that does not have a persistent connection and so uses a cloud agent."),(0,a.kt)("li",{parentName:"ul"},"The person does not want to allow correlation of their agent across relationships and so they use a shared, common endpoint (e.g. ",(0,a.kt)("a",{parentName:"li",href:"https://agents-R-Us.com"},"https://agents-R-Us.com"),') that they are "hidden in a crowd".'),(0,a.kt)("li",{parentName:"ul"},"An enterprise wants a single gateway to the many enterprise agents they have in their organization.")),(0,a.kt)("p",null,"Thus, when a DIDComm message is sent from one edge agent to another, it is routed per the instructions of the receiver and for the needs of the sender. For example, in the following picture, Alice might be told by Bob to send messages to his phone (agent 4) via agents 9 and 3, and Alice might always send out messages via agent 2."),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://github.com/hyperledger/aries-rfcs/raw/master/features/0067-didcomm-diddoc-conventions/domains.jpg",alt:"image"})),(0,a.kt)("p",null,"The following looks at how those requirements are met with mediators (for example, agents 9 and 3) and relays (agent 2)."),(0,a.kt)("h2",{id:"inbound-routing---mediators"},"Inbound Routing - Mediators"),(0,a.kt)("p",null,'To tell a sender how to get a message to it, an agent puts into the DIDDoc for that sender a service endpoint for the recipient (with an encryption key) and an ordered list (possibly empty) of routing keys (called "mediators") to use when sending the message. To send the message, the sender must:'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Prepare the message to be sent to the recipient"),(0,a.kt)("li",{parentName:"ul"},'Successively encrypt and wrap the message for each intermediate mediator in a "forward" message - an envelope.'),(0,a.kt)("li",{parentName:"ul"},"Encrypt and send the message to the first agent in the routing")),(0,a.kt)("p",null,"Note that when an agent uses mediators, it is there responsibility to notify any mediators that need to know of the new relationship that has been formed using the connection protocol and the routing needs of that relationship - where to send messages that arrive destined for a given verkey. Mediator agents have what amounts to a routing table to know when they receive a forward message for a given verkey, where it should go."),(0,a.kt)("p",null,"Link: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/hyperledger/aries-rfcs/tree/master/features/0067-didcomm-diddoc-conventions"},"DIDDoc conventions for inbound routing")),(0,a.kt)("h2",{id:"relays"},"Relays"),(0,a.kt)("p",null,'Inbound routing described above covers mediators for the receiver that the sender must know about. In addition, either the sender or the receiver may also have relays they use for outbound messages. Relays are routing agents not known to other parties, but that participate in message routing. For example, an enterprise agent might send all outbound traffic to a single gateway in the organization. When sending to a relay, the sender just wraps the message in another "forward" message envelope.'),(0,a.kt)("p",null,"Link: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/hyperledger/aries-rfcs/tree/master/concepts/0046-mediators-and-relays"},"Mediators and Relays")),(0,a.kt)("h2",{id:"message-encryption"},"Message Encryption"),(0,a.kt)("p",null,"The DIDComm encryption handling is handling within the Aries agent, and not really something a developer building applications using an agent needs to worry about. Further, within an Aries agent, the handling of the encryption is left to libraries to handle - ultimately calling dependencies from Hyperledger Ursa. To encrypt a message, the agent code calls a ",(0,a.kt)("inlineCode",{parentName:"p"},"pack()")," function to handle the encryption, and to decrypt a message, the agent code calls a corresponding ",(0,a.kt)("inlineCode",{parentName:"p"},"unpack()"),' function. The "wire messages" (as originally called) are described in ',(0,a.kt)("a",{parentName:"p",href:"https://github.com/hyperledger/aries-rfcs/blob/master/features/0019-encryption-envelope/README.md"},"detail here"),", including variations for sender authenticated and anonymous encrypting. Wire messages were meant to indicate the handling of a message from one agent directly to another, versus the higher level concept of routing a message from an edge agent to a peer edge agent."),(0,a.kt)("p",null,"Much thought has also gone into repudiable and non-repudiable messaging, as ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/hyperledger/aries-rfcs/tree/master/concepts/0049-repudiation"},"described here"),"."))}g.isMDXComponent=!0}}]);